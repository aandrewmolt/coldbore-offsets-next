// ZIP Export Module - Bundles PPTX + project info into a downloadable ZIP
// Uses JSZip for archive creation and file-saver for download trigger

import { Photo, Well, GPSLocation, CategoryDefinition } from './types';
import { CONFIG } from './config';
import { formatFileSize } from './utils';
import { generatePptxBlob, AppStoreState, ExportOptions } from './export-pptx';

// --------------------------------------------------------------------------
// Helpers
// --------------------------------------------------------------------------

function sanitizeFilename(str: string): string {
  return str.replace(/[^a-z0-9]/gi, '_');
}

function getCategoryLabel(category: string, categories?: CategoryDefinition[]): string {
  const cats = categories ?? CONFIG.PHOTO_CATEGORIES;
  const def = cats.find((c: CategoryDefinition) => c.value === category);
  return def ? def.label : (category || 'Unassigned');
}

function buildProjectInfoText(state: AppStoreState, pptxFilename: string, categories?: CategoryDefinition[]): string {
  const {
    photos, wells, wellLocations, projectInfo, techName,
    totalOriginalSize, totalOptimizedSize,
  } = state;

  const client = projectInfo.clientName || 'Client';
  const job = projectInfo.jobName || 'Job';
  const organizedCount = photos.filter((p) => p.well && p.category).length;
  const gpsCount = photos.filter((p) => p.metadata?.location || p.manualLocation).length;
  const lagCount = photos.filter((p) => p.hasLongLag).length;
  const spaceSaved = formatFileSize(totalOriginalSize - totalOptimizedSize);

  // Category breakdown
  const categoryCounts: Record<string, number> = {};
  for (const photo of photos) {
    const cat = photo.category || 'unassigned';
    categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
  }

  // Well breakdown
  const wellLines: string[] = [];
  for (const well of wells) {
    const count = photos.filter((p) => p.well === well.name).length;
    const hasGps = !!wellLocations[well.name];
    wellLines.push(`  - ${well.name}: ${count} photo(s)${hasGps ? ' [GPS]' : ''}`);
  }

  const unassignedWellCount = photos.filter((p) => !p.well).length;
  if (unassignedWellCount > 0) {
    wellLines.push(`  - (Unassigned): ${unassignedWellCount} photo(s)`);
  }

  const categoryLines = Object.entries(categoryCounts)
    .sort(([, a], [, b]) => b - a)
    .map(([cat, count]) => `  - ${getCategoryLabel(cat, categories)}: ${count}`);

  const dateStr = projectInfo.jobDateTime
    ? new Date(projectInfo.jobDateTime).toLocaleString()
    : 'Not specified';

  const lines = [
    'SHEARFRAC PHOTO DOCUMENTATION EXPORT',
    '=====================================',
    '',
    `Client: ${client}`,
    `Job: ${job}`,
    `Date/Time: ${dateStr}`,
    ...(techName ? [`Rigged up by: ${techName}`] : []),
    `Export Date: ${new Date().toLocaleString()}`,
    '',
    'STATISTICS:',
    `  - Total Photos: ${photos.length}`,
    `  - Organized Photos: ${organizedCount}`,
    `  - Total Wells: ${wells.length}`,
    `  - Photos with GPS: ${gpsCount}`,
    `  - Long-lag Photos: ${lagCount}`,
    `  - Original Size: ${formatFileSize(totalOriginalSize)}`,
    `  - Optimized Size: ${formatFileSize(totalOptimizedSize)}`,
    `  - Space Saved: ${spaceSaved}`,
    '',
    'WELLS:',
    ...wellLines,
    '',
    'CATEGORY BREAKDOWN:',
    ...categoryLines,
    '',
    'FILES INCLUDED:',
    `  - ${pptxFilename}: Presentation-ready PowerPoint file`,
    `  - PROJECT_INFO.txt: This file`,
    '',
    'NOTES:',
    projectInfo.projectNotes || 'No additional notes',
    '',
    'Generated by: ShearFRAC Photo Documentation System',
  ];

  return lines.join('\n');
}

// --------------------------------------------------------------------------
// Public API
// --------------------------------------------------------------------------

/**
 * Generate a ZIP archive containing:
 *   1. The PowerPoint presentation (PPTX)
 *   2. A PROJECT_INFO.txt summary
 * Then trigger a browser download.
 */
export async function exportZip(state: AppStoreState, options?: ExportOptions): Promise<void> {
  const JSZip = (await import('jszip')).default;
  const { saveAs } = await import('file-saver');

  const client = sanitizeFilename(state.projectInfo.clientName || 'Client');
  const job = sanitizeFilename(state.projectInfo.jobName || 'Job');

  // Generate PPTX blob
  const pptxFilename = `${client}_${job}_ShearFRAC_Report.pptx`;
  const pptxBlob = await generatePptxBlob(state, options);

  // Build project info text
  const projectInfoText = buildProjectInfoText(state, pptxFilename, options?.categories);

  // Create ZIP
  const zip = new JSZip();
  const folderName = `${client}_${job}_ShearFRAC_Package`;
  const folder = zip.folder(folderName);

  if (!folder) {
    throw new Error('Failed to create ZIP folder');
  }

  folder.file(pptxFilename, pptxBlob);
  folder.file('PROJECT_INFO.txt', projectInfoText);

  // Generate ZIP blob
  const zipBlob = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 },
  });

  // Trigger download
  const zipFilename = `${client}_${job}_ShearFRAC_Package.zip`;
  saveAs(zipBlob, zipFilename);
}
